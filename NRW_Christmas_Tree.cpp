// Filename: NRW_Christmas Tree.cpp
// Description:  This program creates a christmas tree out of line segments
// generated by a Bresenham line scan algorithm, it also includes functionality
// for the user to draw line segments via mouse click.
// Date: Jan. 2014
// WRITTEN By: NRW


//The major structure of the is program is to fill buffers with points to be drawn by the 
//display function at each screen reset. There are two major states for this program, the christmas tree
//which is the default state and the line drawing or "click" state. The christmas tree is generated by 
//calling the draw_line function for the 22 line segments listed in the requirements. The jumbo_pixel function is used 
//to generate two vectors of points "X" and "Y" that are then called in the display function. 

//When the user right clicks
//the screen the click state is initiated. This clears the screen, using a seperate set of buffers for the user generated
//line segments. The user can then right click once to save a point, and again to draw a line from the first point to the 
//location of the mouse. These line segments are drawn using the draw_line function and use the jumbo pixels. 
//The user can create as many lines as they'd like. When the user left clicks the program returns to the tree mode and 
//resets all the data for the click mode, allowing the user to start over fresh.



#include "stdafx.h"
#include <Windows.h>
#include <stdio.h>
#include <math.h>
#include <GL/glut.h>
#include <vector>
#include <iostream>
#include "cs_graphics_setup.h"

//------------------------------------------------------------
//Declare constants
#define WINDOW_XS 600
#define WINDOW_YS 600
#define WINDOW_NAME "Christmas Tree - NRW: Right click twice to draw a line, left click to return to the tree"
//------------------------------------------------------------
//Function prototypes
void display_func(void);
void mouse_func(int button, int state, int x, int y);
void draw_line(int x1, int y1, int x2, int y2);
void jumbo_pixel(int x, int y);
void draw_tree();
//------------------------------------------------------------
//Global variables
//These vectors act as buffers that contain the coordinates of 
//each pixel to be lit by the display function
//Seperate buffers are used for each mode so that the tree does not need to be
//recalculated to return to the tree mode
std::vector<int> X;
std::vector<int> Y;
std::vector<int> XCLICK;
std::vector<int> YCLICK;
//variable for determining if first or second click in series
short which_click = 0;
//This variable is to determine if this is the users first click, so that the user's
//second click is used to start drawing lines. 
bool first_click = 0;
//Variables for storing mouse click points
int Click_X_One = NULL;
int Click_Y_One = NULL;
int Click_X_Two = NULL;
int Click_Y_Two = NULL;
//This boolean determines whether we are in xmas tree mode, or user click mode
bool is_tree = true;
//------------------------------------------------------------
int main(int argc, char **argv)
{
	//Initialize GLUT
	glutInit(&argc, argv);
	//Run setup function from cs_graphics_setup.h
	init_setup(WINDOW_XS, WINDOW_YS, WINDOW_NAME);
	//Calculate the points needed for the tree
	draw_tree();
	//Run the display function
	glutDisplayFunc(display_func);
	//Wait for mouse events
	glutMouseFunc(mouse_func);
	//Wait for close
	glutMainLoop();
	return 1;
}
//------------------------------------------------------------
//Jumbo Pixel function
//Takes an X, Y argument and creates a 5X5 jumbo pixel centered at the X, Y coordinates
void jumbo_pixel(int x, int y)
{
	//Start at bottom left of pixel
	x -= 2;
	y -= 2;
	//Calculate upper right coordinates
	int xMax = x + 5;
	int yMax = y + 5;
	//For each column and row, add the x and y coordinates to the buffers containing X and Y
	for (y; y < yMax; y++)
	{
		for (x; x < xMax; x++)
		{
			//If in tree mode
			if (is_tree)
			{
				X.push_back(x);
				Y.push_back(y);
			}
			//else in click mode
			else
			{
				XCLICK.push_back(x);
				YCLICK.push_back(y);
			}
		}
		//Reset x for the loop
		x -= 5;
	}
}
//------------------------------------------------------------
//display_func handles all display variables
void display_func(void)
{
	glClearColor(0.0, 0.0, 0.0, 1.0);
	//Background color (black)
	glClear(GL_COLOR_BUFFER_BIT);
	//Clearing the buffer
	glColor3f(1.0, 1.0, 1.0);
	//Setting pen color (white)
	glBegin(GL_POINTS);
	int xSize = X.size();
	//If the program is in tree mode, draw the tree
	if (is_tree)
	{
		for (int i = 0; i < xSize; i++)
		{
			glVertex2i(X[i], Y[i]);
		}
	}
	//Else in click mode draw the user generated lines
	else
	{
		for (unsigned int i = 0; i < XCLICK.size(); i++)
		{
			glVertex2i(XCLICK[i], YCLICK[i]);
		}
	}
	glEnd();
	glFlush();
}
//------------------------------------------------------------
//Draw line function
//This function implements a Bresenham line drawing algorithm and uses jumbo pixels to draw the line
void draw_line(int x1, int y1, int x2, int y2)
{
	//Assert coordinates are in correct order, if not swap them
	if (x2 - x1 < 0)
	{
		//If dx is negative, swap points
		int x3 = x1;
		x1 = x2;
		x2 = x3;
		int y3 = y1;
		y1 = y2;
		y2 = y3;
	}

	//Store original x and y
	int x = x1;
	int y = y1;
	//Calculate dx, and dy
	int dx = x2 - x1;
	int dy = y2 - y1;
	//Create double version to test the slope for determining which case
	double dxM = dx;
	double dyM = dy;
	//Variable to print every 5th
	short int count = 0;

	//Calculate slope to determine case (only necessary float expression)
	double m = dyM / dxM;

	if (0 <= m && m <= 1)
	{	
		//First case
		//Compute offsets
		int dFa = 2 * (dy - dx);
		int dFb = 2 * dy;

		//Compute initial F
		int F = (2 * dy) - dx;

		//Main loop
		for (x; x < x2; x++)
		{
			//If F > 0 light pixel A
			if (F>0)
			{
				y++;
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFa;
			}
			//Else light B
			else
			{
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFb;
			}
		}
	}
	else if (-1 <= m && m < 0)
	{
		//Second case
		//Adjust dy and dx for this case
		dy = abs(dy);
		dx = -1 * dx;
		//Compute offsets
		int dFa = 2 * (dy + dx);
		int dFb = 2 * dy;
		//Compute initial F
		int F = (2 * dy) + dx;
		//Main loop
		for (x; x < x2; x++)
		{
			//If F > 0 light pixel A
			if (F>0)
			{
				y--;
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFa;
			}
			//Else light B
			else
			{
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFb;
			}
		}
	}
	else if (m>1)
	{
		//Third case
		//Adjust dx and dy for this case
		dx = -1 * dx;
		dy = -1 * dy;
	
		//Compute offsets
		int dFa = 2 * (dy - dx);
		int dFb = -2 * dx;
		//Compute initial F
		int F = dy - (2 * dx);
		//Main loop
		for (y; y < y2; y++)
		{
			//If F > 0 light pixel A
			if (F > 0)
			{
				x++;
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFa;
			}
			//Else light B
			else
			{
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFb;
			}
		}

	}
	else if (m < -1)
	{
		//Fourth case
		//Compute offsets
		int dFa = 2 * (dy + dx);
		int dFb = 2 * dx;
		//Compute Initial F
		int F = dy + (2 * dx);
		//Main loop
		for (y; y > y2; y--)
		{
			//If F > 0 light pixel A
			if (F > 0)
			{
				x++;
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFa;
			}
			//Else light B
			else
			{
				if (count == 4)
				{
					jumbo_pixel(x, y);
					count = 0;
				}
				else
				{
					count++;
				}
				F += dFb;
			}
		}
	}
}
//------------------------------------------------------------
//draw_tree creates all the line segments for the christmas tree and places them in the buffer
void draw_tree()
{
	draw_line(237, 12, 362, 12);
	draw_line(302, 12, 302, 587);
	draw_line(302, 92, 12, 62);
	draw_line(12, 82, 107, 72);
	draw_line(302, 92, 587, 62);

	draw_line(587, 82, 492, 72);
	draw_line(302, 177, 72, 127);
	draw_line(142, 142, 72, 157);
	draw_line(302, 177, 527, 127);
	draw_line(457, 142, 527, 157);

	draw_line(302, 337, 152, 187);
	draw_line(202, 237, 152, 287);
	draw_line(302, 337, 452, 187);
	draw_line(402, 237, 452, 287);
	draw_line(302, 487, 207, 307);

	draw_line(237, 362, 207, 417);
	draw_line(302, 487, 387, 307);
	draw_line(362, 362, 387, 417);
	draw_line(302, 587, 237, 487);
	draw_line(257, 517, 237, 547);

	draw_line(302, 587, 367, 487);
	draw_line(347, 517, 367, 547);
}
//------------------------------------------------------------
//mouse_func handles mouse events
void mouse_func(int button, int state, int x, int y)
{
	//If it is the first click into click mode, turn off the tree and reset the screen
	if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN && which_click == 0 && first_click == 0)
	{
		is_tree = false;
		first_click = 1;
		glutPostRedisplay();
	}
	//This is the first click that registers the origin point for drawing a line
	else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN && which_click == 0 && first_click != 0)
	{
		Click_X_One = x;
		//Convert from GLUT coordinate to GL coordinate
		Click_Y_One = abs(y - WINDOW_YS);
		which_click = 1;
		glutPostRedisplay();
	}
	//This is the second click that draws the line, and then resets for the next line
	else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN && which_click == 1)
	{
		Click_X_Two = x;
		Click_Y_Two = abs(y - WINDOW_YS);
		draw_line(Click_X_One, Click_Y_One, Click_X_Two, Click_Y_Two);
		which_click = 0;
		glutPostRedisplay();
	}
	//On left click, everything is reset and the tree is turned back on
	else if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
	{
		first_click = 0;
		which_click = 0;
		is_tree = true;
		XCLICK.clear();
		YCLICK.clear();
		glutPostRedisplay();
	}
}